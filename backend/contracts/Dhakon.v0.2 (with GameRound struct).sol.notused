// SPDX-License-Identifier: Proprietary

pragma solidity ^0.8.11;

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";


contract Dhakon is VRFConsumerBase {
    address owner;

    uint public ticketPrice;

    struct playerTicket {
        uint ticket;
        address player;
    }

    bool public isPickingWinner;

    struct GameRound {
        address[] players;
        mapping(address => bool) checkPlayers;

        uint[] tickets;
        mapping(uint => address) playerTickets;

        playerTicket winner;

        bool exist;
    }

    GameRound[] public gameRounds;
    uint public roundNum;

    bytes32 internal keyHash; // identifies which Chainlink oracle to use
    uint internal VRFFee;        // fee to get random number

    constructor(
        address _VRFCoordinator, 
        address _LINKToken, 
        bytes32 _keyHash,
        uint _VRFFee,
        uint _ticketPrice)
        VRFConsumerBase(
            _VRFCoordinator,        // Mumbai VRF coordinator 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255
            _LINKToken              // LINK token address 0x326C977E6efc84E512bB9C30f76E30c160eD06FB
        ) {
            keyHash = _keyHash;     // 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4
            VRFFee = _VRFFee;  // 0.0001 * 10 ** 18;    // 0.0001 LINK (Mumbai)
            ticketPrice = _ticketPrice;

            owner = msg.sender;
            roundNum = 1;

            initGameRound();
        }

    function getRandomNumber() internal returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= VRFFee, "Not enough LINK in contract");
        return requestRandomness(keyHash, VRFFee);
    }

    function fulfillRandomness(bytes32 requestId, uint randomness) internal override {
        uint index = randomness % currentRound().tickets.length;
        // payWinner(index);
        isPickingWinner = false;
    }

    function generateTicket() internal view returns (uint) {
        return uint(keccak256(abi.encodePacked(owner, block.timestamp)));
    }

    function initGameRound() internal {
        require(! gameRounds[roundNum].exist, "Game Round already exists");

        gameRounds[roundNum] = GameRound();
    }

    // function getRoundInfo(uint _round) public view returns (GameRound storage) {
    //     return gameRounds[_round];
    // }

    function currentRound() internal view returns (GameRound storage) {
        return gameRounds[roundNum];
    }

/*
    function getWinner() public view returns (playerTicket memory) {
        return currentRound().winner;
    }

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }

    function getPlayers() public view returns (address[] memory) {
        return currentRound().players;
    }

    function getNumOfPlayers() public view returns (uint) {
        return currentRound().players.length;
    }

    function getTickets() public view returns (uint[] memory) {
        return currentRound().tickets;
    }

    function getNumOfTickets() public view returns(uint) {
        return currentRound().tickets.length;
    }

    function addPlayers(address playerAddr) internal {
        if (! gameRounds[roundNum].checkPlayers[playerAddr]) {  // only add if player's address not exist yet
            gameRounds[roundNum].checkPlayers[playerAddr] = true;
            gameRounds[roundNum].players.push(playerAddr);
        }
    }

    function enter() public payable {
        require(msg.value >= ticketPrice);

        // save new ticket entering the round
        uint ticket = generateTicket();
        address payable player = payable(msg.sender);
        gameRounds[roundNum].tickets.push(ticket);
        gameRounds[roundNum].playerTickets[ticket] = player;

        addPlayers(player);
    }

    function pickWinner() public onlyowner {
        require(!isPickingWinner);
        isPickingWinner = true;
        getRandomNumber();
    }

    function payWinner(uint ticketIdx) internal {
        uint ticketNum = currentRound().tickets[ticketIdx];
        currentRound().playerTickets[ticketNum].transfer(address(this).balance);

        gameRounds[roundNum].winner = playerTicket(ticketNum, currentRound().playerTickets[ticketNum]);
        
        // start a NEW Game Round
        roundNum++;
        // initGameRound();
    } */

    function withdrawLINKToken() external onlyowner {
        uint balance = LINK.balanceOf(address(this));
        require(balance > 0, "Balance is 0");
        
        LINK.transfer(owner, balance);
    }

    function setIsPickingWinner(bool _val) external onlyowner {
        isPickingWinner = _val;
    }

    modifier onlyowner() {
      require(msg.sender == owner);
      _;
    }
}